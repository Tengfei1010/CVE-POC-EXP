# Description

Wersvc.dll exists a **Logical Privilege Escalation Vulnerability**

This vulnerability exists in function `CWerService::SvcMergeETWLogs` 

This function will receive a folder, and create a temp file `WER****.tmp` in this folder,and delete it. And this function will also delete the file `WER****.tmp.etl` and create a new one. So attacker can predict the filename and achieve `arbitrary file deletion`

        if ( GetTempFileNameW(folder, L"WER", 0, &TempFileName) ) 
        {
          if ( v10 )
          {
            DeleteFileW(&TempFileName); // del WER****.tmp 
            if ( (int)StringCchCatW(&TempFileName, 0x104ui64, v10) < 0
              && WPP_GLOBAL_Control != &WPP_GLOBAL_Control
              && *((_BYTE *)WPP_GLOBAL_Control + 28) & 1 )
            {
              WPP_SF_d(
                *((_QWORD *)WPP_GLOBAL_Control + 2),
                15i64,
                &WPP_cb9ea6942b973251a45e8aae0c650f46_Traceguids,
                v12);
            }
            DeleteFileW(&TempFileName); // del WER****.tmp.etl 
            v17 = CreateFileW(&TempFileName, 0xC0000000, a7, a6, 1u, a8 | 0x80, 0i64);
 but the file name is generated by the function `GetTempFileNameW` , So to exploit this vulnerability, we should find a race.

* for predicting the filename, we should create as much files as we can in the specified folder with the name `WER****.tmp`  `(**** is 0000-FFFE  )`. So , the filename generated by `GetTempFileNameW` must be `WERFFFF.tmp`;

* Then , I put all the `WER***.tmp`  in `$pwd\1\`, and junction `$pwd\2\ -> $pwd\1\`;

* we  create a process to continuously trigger this function with the path `$pwd\2\`. and create the other process to continuously execute the command `SetOplock $pwd\1\WERFFFF.tmp`;

* Once the Oplock is triggered , we junction `$pwd\2\ -> \RPC CONTROL\`, and then create object symbolic `\RPC CONTROL\WERFFFF.tmp -> $target` and `\RPC CONTROL\WERFFFF.tmp.etl -> $target`
* Release the oplock , the target file will be deleted with system privilege



This kind of vulnerability break the User security boundry of microsoft windows. This POC works in windows 10 1909. Severity of this kind of bug estimated by microsoft is High (7 ~ 8.9).

# POC

* I put `1.txt` in `C:\Windows\` as our target.

* use command `powershell .\GET.ps1` to generate `WER****.tmp`

* use command `powershell .\JunctionAndSetOplock.ps1` in Console1 to junction `$pwd\2\ -> $pwd\1\` and setOplock `$pwd\1\WERFFFF.tmp`;

* use command `powershell .\Trigger.ps1` in console2 to call the vulnerable function 

* Once the oplock is triggered , use command `.\SwitchJunction.ps1` 

* `C:\Windows\1.txt` will be deleted. 

* To exploit this vulnerability , you should win the race,so,if you failed ,please try again.

* (a procmon log file is attached to help you identify the vulnerability)

  â€‹	

  

# Credit:

Zhiniang Peng (@edwardzpeng) of Qihoo 360 Core security & Xuefeng Li 